import chalk from "chalk";
import readlineSync from "readline-sync";

class Player {
  constructor() {
    this.hp = 100;
    this.attackMin = 6;
    this.attackMax = 8;
    this.defense = 12;
  }

  updateState(stage) {
    this.attackMin = 6 + stage * 2;
    this.attackMax = 8 + stage * 2;
  }

  calculateAttack() {
    return (
      Math.floor(Math.random() * (this.attackMax - this.attackMin + 1)) +
      this.attackMin
    );
  }

  attack(monster) {
    const damage = this.calculateAttack();
    monster.hp -= damage;
    return damage;
  }
}

class Monster {
  constructor(stage) {
    this.hp = 50 + stage * 10;
    this.attackMin = 2 + stage * 2;
    this.attackMax = 4 + stage * 2;
  }

  calculateAttack() {
    return (
      Math.floor(Math.random() * (this.attackMax - this.attackMin + 1)) +
      this.attackMin
    );
  }

  attack(player) {
    const damage = this.calculateAttack();
    player.hp -= damage;
    return damage;
  }
}

//스테이지, 플레이어, 몬스터 정보
function displayStatus(stage, player, monster) {
  console.log(chalk.magentaBright(`\n=== Current Status ===`));
  console.log(
    chalk.cyanBright(`| Stage: ${stage} `) +
      chalk.blueBright(
        `| 플레이어 HP : ${player.hp}, Attack : ${player.attackMin}-${player.attackMax}`
      ) +
      chalk.redBright(
        `| 몬스터 HP : ${monster.hp}, Attack : ${monster.attackMin}-${monster.attackMax}|`
      )
  );

  console.log(chalk.magentaBright(`=====================\n`));
}

const battle = async (stage, player, monster) => {
  let logs = [];

  while (player.hp > 0) {
    console.clear();
    displayStatus(stage, player, monster);

    logs.forEach((log) => console.log(log));

    console.log(
      chalk.green(`\n1. 공격한다 2. 연속 공격 3. 방어한다 4. 도망친다`)
    );
    const choice = readlineSync.question("당신의 선택은? ");

    // 플레이어의 선택에 따라 다음 행동 처리

    if (choice === "1") {
      const playerDamage = player.attack(monster);
      logs.push(
        chalk.green(
          `플레이어가 몬스터에게 ${playerDamage}의 피해를 입혔습니다!`
        )
      );
    } else if (choice === "2") {
      for (let i = 0; i < 3; i++) {
        if (monster.hp > 0) {
          const playerDamage = player.attack(monster);

          logs.push(
            chalk.green(
              `플레이어가 몬스터에게 ${playerDamage}의 피해를 입혔습니다!`
            )
          );
        }
      }
    } else if (choice === "3") {
      player.defense += 5; // 임시로 방어력 증가
      logs.push(
        chalk.blue(`플레이어가 방어 자세를 취합니다. 방어력이 증가했습니다!`)
      );
    } else if (choice === "4") {
      const escape = Math.random();
      if (escape < 0.1) {
        logs.push(chalk.yellow(`도망에 성공했습니다!`));
        return true;
      } else {
        logs.push(chalk.red(`도망에 실패했습니다.`));
        const monsterDamage = monster.attack(player);
        logs.push(
          chalk.red(
            `몬스터가 플레이어에게 ${monsterDamage}의 피해를 입혔습니다!`
          )
        );
      }
    }
  }
};

export async function startGame() {
  console.clear();
  const player = new Player();
  let stage = 1;

  while (stage <= 10) {
    const monster = new Monster(stage);
    await battle(stage, player, monster);

    // 스테이지 클리어 및 게임 종료 조건
    if (player.hp > 0) {
      console.log(chalk.yellow(`스테이지 ${stage}를 클리어했습니다!`));
      stage++;
    } else {
      console.log(chalk.red("플레이어가 패배했습니다... 게임 오버."));
      break;
    }
  }

  if (stage > 10) {
    console.log(chalk.green("축하합니다! 모든 스테이지를 클리어했습니다!"));
  }
}
